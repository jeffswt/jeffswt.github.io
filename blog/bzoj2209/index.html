<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="theme-color" content="#292d35">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>bzoj2209: [Jsoi2011]括号序列&nbsp;&nbsp;|&nbsp;&nbsp;jeffswt: the ac moments</title>
  <link rel="shortcut icon" href="/assets/images/favicon.png">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="/assets/font-awesome.css">
  <link rel="stylesheet" href="/assets/katex/katex.css">
  <link rel="stylesheet" href="/assets/gitment/gitment.css">
</head>

<body>
  <div class="topbar">
    <div class="bar">
      <span class="avatar-icon"><svg version="1.1" height="40px" version="1.1" viewBox="0 0 48 48" width="40px">
        <polygon points="-0.5,16 -0.5,37 0.5,34 0.5,32 1.5,28.8 1.5,24 1.5,21 2.5,17.6 2.5,16 1,14.9 "/>
        <polygon points="44,0.5 45,0.5 46.1,1.1 46.9,1.9 47.2,2.8 47.5,4.8 47.5,7 48,43.8 47.6,45.8 46.4,47.6
        	44.8,48.5 38,48.5 36.8,47.2 36.1,46.1 34.2,44.7 32.6,43.5 31.1,40.8 29.5,38.8 27.8,35.9 26.9,35.4 29.5,35.3 32.7,28.4
        	31.4,27.8 28.7,33.8 26.9,34.1 25.7,33.3 23.5,33.4 21,32.8 19.3,32.2 18.3,30.4 17.3,27.3 19.3,27.9 20.8,26.6 20.4,25.3 21.3,24
        	22.2,23 20.3,21.3 17.8,20.8 16.2,21.5 15.5,23 15.5,25 14.4,26 12.8,26.6 11.2,29.2 10.6,31.1 11.2,34.3 10.9,37.7 11,39.5
        	11.8,42.3 9.5,39.6 8.6,37 7.8,35.1 7.1,33.4 6.6,31 6,28.1 5.6,23.5 6.2,21.8 5.6,19.3 6.3,18.1 8.4,17 10.8,14.5 13,14.5
        	15.8,16.5 19,16.5 22.2,14.3 24,15 25.4,13.5 29,13.5 32.3,12.3 34.5,11.3 36,10.5 36.4,9 39.3,8.8 40.1,7.5 42,7.5 43.6,6.9
        	44,5.3 44.8,3.9 45.2,2.7 "/>
        <polygon points="17.5,34 17.5,37 18.2,37.5 22.8,35.4 21.1,34.7 17.9,34 "/>
        <polygon points="19,43.1 20.6,42.4 22.1,41.4 24,39.5 25,39.5 26.8,41.3 29.3,44.6 24,43.3 "/>
      </svg></span>
      <span class="site-title"><a class="site-title-href" href="/blog/">
        jeffswt: the ac moments
      </a></span>
    </div>
  </div>
  <div class="site-content">
    <div class="blog-post" lang="zh">
      <div class="post-header">
        <h1 class="title">
          bzoj2209: [Jsoi2011]括号序列
        </h1>
        <span class="tags">
          <a class="tag" href="/blog/archive/?q=Problems" target="_self">
            <i class="fa fa-tag"></i> Problems
          </a>
          <a class="tag" href="/blog/archive/?q=BZOJ2009" target="_self">
            <i class="fa fa-tag"></i> BZOJ2009
          </a>
          <a class="tag" href="/blog/archive/?q=JSOI2011" target="_self">
            <i class="fa fa-tag"></i> JSOI2011
          </a>
          <a class="tag" href="/blog/archive/?q=Splay Tree" target="_self">
            <i class="fa fa-tag"></i> Splay Tree
          </a>
        </span>
        <span class="date" title="14:24:23 | 4 February, 2017">
          4 February, 2017
        </span>
      </div>
      <div class="post-content">
        <h2 id="description">Description</h2>
<p>JSOI 教练组按如下定义配对的括号序列:</p>
<ol type="1">
<li><span class="math inline">\(()\)</span> 是配对的括号序列.</li>
<li>若 <span class="math inline">\(A\)</span> 是配对的括号序列, 则 <span class="math inline">\((A)\)</span> 也是配对的括号序列.</li>
<li>若 <span class="math inline">\(A, B\)</span> 是配对的括号序列, 则 <span class="math inline">\(AB\)</span> 也是配对的括号序列.</li>
</ol>
<p>例如, 以下是配对的括号序列:</p>
<p><span class="math display">\[(())()()((()())), ((((())))), ()()()()(())\]</span></p>
<p>以下则是不配对的括号序列:</p>
<p><span class="math display">\[)()()()()()(, (())((), (())(()))()(()\]</span></p>
<p>繁多的括号总是让 JSOI 教练组看花眼, 难以分辨一个很长的括号序列究竟是不是配对的, 所以他请你编写一个程序, 输入一个括号序列, 并能够完成以下三种操作:</p>
<ol type="1">
<li>询问将 <span class="math inline">\(A[x], A[x+1], \ldots, A[y]\)</span> 形成的括号序列修改为配对的括号序列, 至少 需要修改多少个括号.</li>
<li>将 <span class="math inline">\(A[x], A[x+1], \ldots, A[y]\)</span> 的子序列执行反转, 所有的 <span class="math inline">\((\)</span> 修改为 <span class="math inline">\()\)</span>, 所有 的 <span class="math inline">\()\)</span> 修改为 <span class="math inline">\((\)</span>.</li>
<li>将 <span class="math inline">\(A[x], A[x+1], \ldots, A[y]\)</span> 的子序列执行翻转, 原子序列被 <span class="math inline">\(A[y], A[y-1], \ldots, A[x]\)</span> 替代.</li>
</ol>
<h2 id="input">Input</h2>
<p>输入数据的第一行包含两个整数 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(Q\)</span>, 分别表示括号序列的长度, 以及操作的个数.</p>
<p>第二行包含一个长度为 <span class="math inline">\(n\)</span> 的括号序列.</p>
<p>接下来 <span class="math inline">\(Q\)</span> 行, 每行三个整数 <span class="math inline">\(t, x, y\)</span>, 分别表示操作的类型、操作的开始位置和操作的结束位置, 输入数据保证 <span class="math inline">\(x \leq y\)</span>. 其中 <span class="math inline">\(t = 0\)</span> 表示询问操作、<span class="math inline">\(t = 1\)</span> 表示反转 操作、<span class="math inline">\(t = 2\)</span> 表示翻转操作.</p>
<h2 id="output">Output</h2>
<p>对于每一个询问操作, 输出一行, 表示将括号序列的该子序列修改为配对, 所需的最少改动个数.</p>
<!-- More -->
<h2 id="sample-input">Sample Input</h2>
<pre><code>6 3
)(())(
0 1 6
0 1 4
0 3 4</code></pre>
<h2 id="sample-output">Sample Output</h2>
<pre><code>2
2
0</code></pre>
<h2 id="data-range">Data Range</h2>
<p>对于 100% 的数据, 满足:<span class="math inline">\(0 \lt n, q \leq 10^5\)</span></p>
<h2 id="explanation">Explanation</h2>
<p>原文链接:<a href="">http://blog.csdn.net/lych_cys/article/details/50700277</a></p>
<p>首先, 对于一个括号序列, 例如:<span class="math inline">\(())()(((\)</span>, 我们把可以匹配的去掉, 就变成了:<span class="math inline">\()(((\)</span>. 换句话说, 对于一般的括号序列, 化简以后就变成了左边 <span class="math inline">\(x\)</span> 个 <span class="math inline">\()\)</span>, 右边 <span class="math inline">\(y\)</span> 个 <span class="math inline">\((\)</span>. 显然 <span class="math inline">\(x + y\)</span> 为偶数, 我们可以发现此时答案为 <span class="math inline">\(\frac{x}{2}+\frac{y}{2}\)</span> (<span class="math inline">\(x, y\)</span> 为偶数) 或者 <span class="math inline">\(\frac{x}{2}+1+\frac{y}{2}+1\)</span> (<span class="math inline">\(x, y\)</span> 为奇数), 合并一下就是 <span class="math inline">\([\frac{x+1}{2}]+[\frac{y+1}{2}]\)</span>.</p>
<p>关键是对于序列 <span class="math inline">\((l, r)\)</span>,<span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 怎么求. 实际上我们发现 <span class="math inline">\(x\)</span> 就是求左端点为 <span class="math inline">\(l\)</span>, 右端点 <span class="math inline">\(\leq r\)</span> 时, 序列中右括号比左括号多的个数的最大值 <span class="math inline">\((\gt 0)\)</span>. 换句话说, 如果令 <span class="math inline">\(( = 1, ) = -1\)</span>, 实际上 <span class="math inline">\(x\)</span> 就是最小左子段和,<span class="math inline">\(y\)</span> 就是最大右子段和. 由于 还有反转 (不是翻转) 操作, 因此还需要维护最大左子段和和最小右子段和. 为了维护最小 最大子段和, 还需要维护一个区间和.</p>
<p>顺便吐槽一下, Splay 调了好久对拍也没有问题, 最后发现是 Query 写错了 (向下取整) 然后发现实在是太制杖...... QwQ</p>
<h2 id="source-code">Source Code</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;cstdio&gt;</span>

<span class="ot">#define SWTAPI inline</span>
<span class="ot">#define rep(_var,_begin,_end) for(int _var=_begin;_var&lt;=_end;_var++)</span>
<span class="ot">#define range(_begin,_end) rep(_,_begin,_end)</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> lli;
<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">200100</span>;

<span class="kw">class</span> SplayTree
{
<span class="kw">public</span>:
    <span class="dt">int</span> arr_i[maxn][<span class="dv">12</span>];
    <span class="ot">#define lc(_x) arr_i[_x][0]</span>
    <span class="ot">#define rc(_x) arr_i[_x][1]</span>
    <span class="ot">#define ch(_x,_y) arr_i[_x][_y]</span>
    <span class="ot">#define par(_x) arr_i[_x][2]</span>
    <span class="ot">#define size(_x) arr_i[_x][3]</span>
    <span class="ot">#define val(_x) arr_i[_x][4]</span>
    <span class="ot">#define vsm(_x) arr_i[_x][5]</span>
    <span class="ot">#define lmn(_x) arr_i[_x][6]</span>
    <span class="ot">#define rmn(_x) arr_i[_x][7]</span>
    <span class="ot">#define lmx(_x) arr_i[_x][8]</span>
    <span class="ot">#define rmx(_x) arr_i[_x][9]</span>
    <span class="ot">#define lazyrev(_x) arr_i[_x][10]</span>
    <span class="ot">#define lazyinv(_x) arr_i[_x][11]</span>
    <span class="dt">int</span> root, ncnt;
    SWTAPI <span class="dt">int</span> make_node(<span class="dt">int</span> v)
    {
        <span class="dt">int</span> p = ++ncnt;
        lc(p) = rc(p) = par(p) = <span class="dv">0</span>;
        size(p) = <span class="dv">1</span>, val(p) = vsm(p) = v;
        lmn(p) = rmn(p) = min(p, <span class="dv">0</span>);
        lmx(p) = rmx(p) = max(p, <span class="dv">0</span>);
        lazyrev(p) = lazyinv(p) = <span class="dv">0</span>;
        <span class="kw">return</span> p;
    }
    SWTAPI <span class="dt">void</span> mark_rev(<span class="dt">int</span> p)
    {
        <span class="kw">if</span> (!p) <span class="kw">return</span> ;
        lazyrev(p) ^= <span class="dv">1</span>;
        swap(lmn(p), rmn(p));
        swap(lmx(p), rmx(p));
        <span class="kw">return</span> ;
    }
    SWTAPI <span class="dt">void</span> mark_inv(<span class="dt">int</span> p)
    {
        <span class="kw">if</span> (!p) <span class="kw">return</span> ;
        lazyinv(p) ^= <span class="dv">1</span>;
        swap(lmn(p), lmx(p));
        swap(rmn(p), rmx(p));
        val(p) = -val(p); vsm(p) = -vsm(p);
        lmn(p) = -lmn(p); lmx(p) = -lmx(p);
        rmn(p) = -rmn(p); rmx(p) = -rmx(p);
        <span class="kw">return</span> ;
    }
    SWTAPI <span class="dt">void</span> update_lazy(<span class="dt">int</span> p)
    {
        size(p) = size(lc(p)) + <span class="dv">1</span> + size(rc(p));
        vsm(p) = vsm(lc(p)) + val(p) + vsm(rc(p));
        lmn(p) = min(lmn(lc(p)), vsm(lc(p)) + val(p) + lmn(rc(p)));
        lmx(p) = max(lmx(lc(p)), vsm(lc(p)) + val(p) + lmx(rc(p)));
        rmn(p) = min(rmn(rc(p)), vsm(rc(p)) + val(p) + rmn(lc(p)));
        rmx(p) = max(rmx(rc(p)), vsm(rc(p)) + val(p) + rmx(lc(p)));
        <span class="kw">return</span> ;
    }
    SWTAPI <span class="dt">void</span> push_down(<span class="dt">int</span> p)
    {
        <span class="kw">if</span> (lazyrev(p)) {
            swap(lc(p), rc(p));
            mark_rev(lc(p)); mark_rev(rc(p));
            lazyrev(p) = <span class="kw">false</span>;
        }
        <span class="kw">if</span> (lazyinv(p)) {
            mark_inv(lc(p)); mark_inv(rc(p));
            lazyinv(p) = <span class="kw">false</span>;
        }
        <span class="kw">return</span> ;
    }
    SWTAPI <span class="dt">void</span> rotate(<span class="dt">int</span> p)
    {
        <span class="dt">int</span> q = par(p), g = par(q);
        push_down(q);
        push_down(p);
        <span class="dt">int</span> x = p == rc(q), y = q == rc(g);
        ch(q, x) = ch(p, !x); <span class="kw">if</span> (ch(q, x)) par(ch(q, x)) = q;
        ch(p, !x) = q; par(q) = p;
        <span class="kw">if</span> (g) ch(g, y) = p; par(p) = g;
        update_lazy(q);
        update_lazy(p);
        <span class="kw">return</span> ;
    }
    SWTAPI <span class="dt">void</span> splay(<span class="dt">int</span> p, <span class="dt">int</span> t)
    {
        <span class="kw">for</span> (<span class="dt">int</span> q = <span class="dv">0</span>; (q = par(p)) &amp;&amp; q != t; rotate(p))
            <span class="kw">if</span> (par(q) &amp;&amp; par(q) != t)
                rotate((p == rc(p)) == (q == rc(par(q))) ? q : p);
        <span class="kw">if</span> (t == <span class="dv">0</span>) root = p;
        <span class="kw">return</span> ;
    }
    SWTAPI <span class="dt">int</span> find(<span class="dt">int</span> sz)
    {
        <span class="dt">int</span> p = root;
        <span class="kw">while</span> (<span class="kw">true</span>) {
            push_down(p);
            <span class="kw">if</span> (sz &lt;= size(lc(p))) {
                p = lc(p);
                <span class="kw">continue</span>;
            } sz -= size(lc(p));
            <span class="kw">if</span> (sz &lt;= <span class="dv">1</span>) {
                <span class="kw">return</span> p;
            } sz -= <span class="dv">1</span>;
            p = rc(p);
        }
        <span class="kw">return</span> p;
    }
    SWTAPI <span class="dt">int</span> query(<span class="dt">int</span> l, <span class="dt">int</span> r)
    {
        <span class="dt">int</span> lp = find(l), rp = find(r + <span class="dv">2</span>);
        splay(lp, <span class="dv">0</span>);
        splay(rp, root);
        <span class="dt">int</span> p = lc(rp);
        <span class="co">// update_lazy(p);</span>
        <span class="co">// int res = int((- lmn(p) + 1) / 2)</span>
        <span class="co">//     + int((rmx(p) + 1) / 2);</span>
        <span class="dt">int</span> res = (rmx(p) + <span class="dv">1</span>) / <span class="dv">2</span> - (lmn(p) - <span class="dv">1</span>) / <span class="dv">2</span>;
        <span class="kw">return</span> res;
    }
    SWTAPI <span class="dt">void</span> inverse(<span class="dt">int</span> l, <span class="dt">int</span> r)
    {
        <span class="dt">int</span> lp = find(l), rp = find(r + <span class="dv">2</span>);
        splay(lp, <span class="dv">0</span>);
        splay(rp, root);
        <span class="dt">int</span> p = lc(rp);
        mark_inv(p);
        splay(p, <span class="dv">0</span>);
        <span class="kw">return</span> ;
    }
    SWTAPI <span class="dt">void</span> reverse(<span class="dt">int</span> l, <span class="dt">int</span> r)
    {
        <span class="dt">int</span> lp = find(l), rp = find(r + <span class="dv">2</span>);
        splay(lp, <span class="dv">0</span>);
        splay(rp, root);
        <span class="dt">int</span> p = lc(rp);
        mark_rev(p);
        splay(p, <span class="dv">0</span>);
        <span class="kw">return</span> ;
    }
    SWTAPI <span class="dt">int</span> dfs_build(<span class="dt">int</span> l, <span class="dt">int</span> r, <span class="dt">char</span> str[])
    {
        <span class="kw">if</span> (l &gt; r)
            <span class="kw">return</span> <span class="dv">0</span>;
        <span class="dt">int</span> mid = (l + r) &gt;&gt; <span class="dv">1</span>;
        <span class="dt">int</span> val = str[mid] == <span class="st">'('</span> ? <span class="dv">1</span> : <span class="dv">-1</span>;
        <span class="dt">int</span> p = make_node(val);
        lc(p) = dfs_build(l, mid - <span class="dv">1</span>, str);
        rc(p) = dfs_build(mid + <span class="dv">1</span>, r, str);
        range(<span class="dv">0</span>, <span class="dv">1</span>) <span class="kw">if</span> (ch(p, _)) par(ch(p, _)) = p;
        update_lazy(p);
        <span class="kw">return</span> p;
    }
    SWTAPI <span class="dt">void</span> build_tree(<span class="dt">int</span> n, <span class="dt">char</span> str[])
    {
        ncnt = <span class="dv">0</span>;
        str[<span class="dv">0</span>] = str[n + <span class="dv">1</span>] = <span class="st">'-'</span>;
        root = dfs_build(<span class="dv">0</span>, n + <span class="dv">1</span>, str);
        <span class="kw">return</span> ;
    }
} st;

<span class="dt">int</span> n, Q;
<span class="dt">char</span> str[maxn];

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>** argv)
{
    scanf(<span class="st">"</span><span class="ch">%d%d</span><span class="st">"</span>, &amp;n, &amp;Q);
    scanf(<span class="st">"</span><span class="ch">%s</span><span class="st">"</span>, str + <span class="dv">1</span>);
    st.build_tree(n, str);
    <span class="kw">for</span> (<span class="dt">int</span> idx = <span class="dv">1</span>; idx &lt;= Q; idx++) {
        <span class="dt">int</span> t, l, r;
        scanf(<span class="st">"</span><span class="ch">%d%d%d</span><span class="st">"</span>, &amp;t, &amp;l, &amp;r);
        <span class="kw">if</span> (t == <span class="dv">0</span>) {
            <span class="dt">int</span> res = st.query(l, r);
            printf(<span class="st">"</span><span class="ch">%d\n</span><span class="st">"</span>, res);
        } <span class="kw">else</span> <span class="kw">if</span> (t == <span class="dv">1</span>) {
            st.inverse(l, r);
        } <span class="kw">else</span> <span class="kw">if</span> (t == <span class="dv">2</span>) {
            st.reverse(l, r);
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>

      </div>
      <div class="post-footer">
        <span class="share">
          <i class="fa fa-share-alt"></i>share to:
          <a href="https://www.facebook.com/sharer/sharer.php?u=https://jeffswt.tk//blog/bzoj2209/"><i class="fa fa-facebook"></i>facebook</a>
          <a href="https://twitter.com/intent/tweet?text=https://jeffswt.tk//blog/bzoj2209/"><i class="fa fa-twitter"></i>twitter</a>
          <a href="https://plus.google.com/share?url=https://jeffswt.tk//blog/bzoj2209/"><i class="fa fa-google-plus"></i>google+</a>
          <a href="https://www.reddit.com/submit?url=https://jeffswt.tk//blog/bzoj2209/"><i class="fa fa-reddit"></i>reddit</a>
        </span>
        <hr />
      </div>
    </div>
    <div id="comments-section" data-id="bzoj2209">
    </div>
  </div>
  <div class="page-footer">
    <center><span class="copyright">
      &copy; 2017 jeffswt, all rights reserved.
    </span></center>
  </div>

  <script type="text/javascript" src="/assets/katex/katex.js"></script>
  <script type="text/javascript" src="/assets/katex/contrib/auto-render.js"></script>
  <script type="text/javascript" src="/assets/gitment/gitment.js"></script>
  <script type="text/javascript" src="/assets/main.js"></script>

  <div hidden="hidden">
    <script type="text/javascript" src="https://s11.cnzz.com/z_stat.php?id=1261583208&web_id=1261583208"></script>
  </div>
</body>
</html>
